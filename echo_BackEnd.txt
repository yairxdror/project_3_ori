=== app.ts ===
import express from "express";
import cors from "cors";
import path from "path";
import { appConfig } from "./utils/config";
import { isDBup } from "./helpers/generalHelpers";
import { vacationRouter } from "./Controllers/vacationController";
import { userRouter } from "./Controllers/userController";
import errorHandler from "./middlewares/errorsHandler";
import fs from "fs";

async function bootstrap() {
  const dbOk = await isDBup();
  if (!dbOk) process.exit(1);

  console.log("DB is working");

  const server = express();

  // CORS
  server.use(
    cors({
      origin: [
        "http://127.0.0.1:3000",
        "http://localhost:5173",
        "http://localhost:5174",
      ],
      credentials: true,
    })
  );

  const imagesDir = path.join(process.cwd(), "images");
  if (!fs.existsSync(imagesDir)) {
    fs.mkdirSync(imagesDir, { recursive: true });
  }

  server.use(express.json());

  server.use("/api", userRouter);
  server.use("/api", vacationRouter);

  server.use("/images", express.static(imagesDir));

  // Test route
  server.get("/ping", (_req, res) => {
    console.log("GET /ping hit");
    res.send("pong");
  });

  server.use(errorHandler);

  server.listen(appConfig.port, () => {
    console.log(`Express server started.\nhttp://localhost:${appConfig.port}`);
  });
}

bootstrap().catch((err) => {
  console.error("Fatal error during server startup", err);
  process.exit(1);
});

=== Controllers\userController.ts ===
import express, { Request, Response, NextFunction } from "express";
import * as userServices from "../services/userServices";
import verifyLoggedIn from "../middlewares/verifyLoggedIn";

export const userRouter = express.Router();

// Register a new user
userRouter.post("/user/register", async (req: Request, res: Response, next: NextFunction) => {
 try {
      // req.body: { firstName, lastName, email, password }
      const token = await userServices.registerUser(req.body);
      res.status(201).json({ token });
    } catch (err) {
      next(err);
    }
});

// Login existing user
userRouter.post("/user/login", async (req: Request, res: Response, next: NextFunction) => {
  try {
      // req.body: { email, password }
      const token = await userServices.login(req.body);
      res.status(200).json({ token });
    } catch (err) {
      next(err);
    }
});

// Check email availability
userRouter.get("/user/check-email", async (req: Request, res: Response, next: NextFunction) => {
  try {
      const email = req.query.email as string;
      const isFree = await userServices.isEmailFree(email);
      res.json({ isFree });
    } catch (err) {
      next(err);
    }
});

// Get details of the logged-in user
userRouter.get("/user/me",verifyLoggedIn, async (req: Request, res: Response, next: NextFunction) => {
 try {
      const user = (req as any).user; 
      res.json(user);
    } catch (err) {
      next(err);
    }
});

=== Controllers\vacationController.ts ===
import express, { Request, Response, NextFunction } from "express";
import multer from "multer";
import path from "path";
import fs from "fs";
import crypto from "crypto";

import verifyLoggedIn from "../middlewares/verifyLoggedIn";
import verifyAdmin from "../middlewares/verifyAdmin";
import verifyNotAdmin from "../middlewares/verifyNotAdmin";

import {
  getVacationsForUser,
  getVacationById,
  addVacation,
  updateVacation,
  deleteVacation,
  followVacation,
  unfollowVacation,
  getVacationsReport,
  generateCsvReport,
} from "../services/vacationServices";

export const vacationRouter = express.Router();

// Ensure the `images` directory exists in the project
const imagesDir = path.resolve(process.cwd(), "images");
if (!fs.existsSync(imagesDir)) {
  fs.mkdirSync(imagesDir, { recursive: true });
}

const allowedMimeTypes = new Set([
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/gif",
]);

const storage = multer.diskStorage({
  destination: (_req, _file, cb) => cb(null, imagesDir),
  filename: (_req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    const safeExt = ext || "";
    const name = crypto.randomUUID();
    cb(null, `${name}${safeExt}`);
  },
});

const upload = multer({
  storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
  },
  fileFilter: (_req, file, cb) => {
    if (!allowedMimeTypes.has(file.mimetype)) {
      return cb(new multer.MulterError("LIMIT_UNEXPECTED_FILE", "image"));
    }
    cb(null, true);
  },
});

// Safely unlink an image file (won't crash the server if file is missing)
async function safeUnlinkImage(fileName?: string) {
  if (!fileName) return;

  const fullPath = path.resolve(imagesDir, fileName);

  // Basic protection against path traversal
  if (!fullPath.startsWith(imagesDir + path.sep) && fullPath !== path.join(imagesDir, fileName)) {
    return;
  }

  try {
    await fs.promises.unlink(fullPath);
  } catch (err: any) {
    if (err?.code === "ENOENT") return;
    console.error("Failed deleting image:", err);
  }
}

// Middleware that converts Multer errors to 400 (Bad Request) instead of 500
function uploadSingleImage(req: Request, res: Response, next: NextFunction) {
  const handler = upload.single("image");
  handler(req, res, (err: any) => {
    if (!err) return next();

    if (err instanceof multer.MulterError) {
      if (err.code === "LIMIT_FILE_SIZE") {
        return res.status(400).json({ message: "Image is too large (max 5MB)" });
      }
      return res.status(400).json({ message: "Invalid image file" });
    }

    return res.status(400).json({ message: err?.message || "Invalid upload" });
  });
}

// Returns all vacations for the logged-in user, including filtering and pagination
vacationRouter.get("/vacations", verifyLoggedIn, async (req, res, next) => {
  try {
    const currentUser = (req as any).user;
    const userId = Number(currentUser.id);

    const page = req.query.page ? Number(req.query.page) : 1;
    const pageSize = req.query.pageSize ? Number(req.query.pageSize) : 6;
    const filter = req.query.filter as any;

    const result = await getVacationsForUser(userId, { page, pageSize, filter });
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// for admin — Graph
vacationRouter.get("/vacations/report", verifyLoggedIn, verifyAdmin,
  async (_req: Request, res: Response, next: NextFunction) => {
    try {
      const report = await getVacationsReport();
      res.json(report);
    } catch (error) {
      next(error);
    }
  }
);

// Export CSV report — admin only
vacationRouter.get("/vacations/report/csv", verifyLoggedIn, verifyAdmin,
  async (_req: Request, res: Response, next: NextFunction) => {
    try {
      const csv = await generateCsvReport();
      res.setHeader("Content-Type", "text/csv");
      res.setHeader(
        "Content-Disposition",
        'attachment; filename="vacations-report.csv"'
      );
      res.send(csv);
    } catch (error) {
      next(error);
    }
  }
);

// Returns a single vacation
vacationRouter.get("/vacations/:id", verifyLoggedIn,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const vacationId = Number(req.params.id);
      const currentUser = (req as any).user;
      const userId = Number(currentUser.id);

      const vacation = await getVacationById(vacationId, userId);
      if (!vacation) {
        return res.status(404).json({ message: "Vacation not found" });
      }

      res.json(vacation);
    } catch (error) {
      next(error);
    }
  }
);

// Create a new vacation — admin only
vacationRouter.post("/vacations", verifyLoggedIn, verifyAdmin, uploadSingleImage,
  async (req: Request, res: Response, next: NextFunction) => {
    const imageFileName = (req as any).file?.filename as string | undefined;

    try {
      if (!imageFileName) {
        return res.status(400).json({ message: "Image file is required" });
      }

      const { destination, description, startDate, endDate, price } = req.body;

      const created = await addVacation({
        destination,
        description,
        startDate,
        endDate,
        price: Number(price),
        image: imageFileName,
      });

      res.status(201).json(created);
    } catch (error) {
      // If the operation fails after upload, remove the uploaded file
      await safeUnlinkImage(imageFileName);
      next(error);
    }
  }
);

// Update vacation — admin only (image optional)
vacationRouter.put("/vacations/:id", verifyLoggedIn, verifyAdmin, uploadSingleImage,
  async (req: Request, res: Response, next: NextFunction) => {
    const newImageFileName = (req as any).file?.filename as string | undefined;

    try {
      const id = Number(req.params.id);
      const { destination, description, startDate, endDate, price } = req.body;

      // Load existing vacation to determine the previous image
      const existing = await getVacationById(id);
      if (!existing) {
        // If a new image was uploaded but the vacation does not exist, delete the new image
        await safeUnlinkImage(newImageFileName);
        return res.status(404).json({ message: "Vacation not found" });
      }

      const updated = await updateVacation({
        id,
        destination,
        description,
        startDate,
        endDate,
        price: Number(price),
        image: newImageFileName,
      });

      // If a new image was uploaded, delete the old image (after successful update)
      if (newImageFileName && existing.image && existing.image !== newImageFileName) {
        await safeUnlinkImage(existing.image);
      }

      res.json(updated);
    } catch (error) {
      // If the operation fails after uploading a new image, delete it
      await safeUnlinkImage(newImageFileName);
      next(error);
    }
  }
);

// Delete vacation — admin only
vacationRouter.delete("/vacations/:id", verifyLoggedIn, verifyAdmin,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const id = Number(req.params.id);
      const existing = await getVacationById(id);
      if (!existing) {
        return res.status(404).json({ message: "Vacation not found" });
      }
      await deleteVacation(id);
      await safeUnlinkImage(existing.image);
      res.sendStatus(204);
    } catch (error) {
      next(error);
    }
  }
);

// Follow a vacation — users only
vacationRouter.post("/vacations/:id/follow", verifyLoggedIn, verifyNotAdmin,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const vacationId = Number(req.params.id);
      const currentUser = (req as any).user;
      const userId = Number(currentUser.id);

      await followVacation(userId, vacationId);
      res.sendStatus(201);
    } catch (error) {
      next(error);
    }
  }
);

// Unfollow a vacation — users only
vacationRouter.delete("/vacations/:id/follow", verifyLoggedIn, verifyNotAdmin,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const vacationId = Number(req.params.id);
      const currentUser = (req as any).user;
      const userId = Number(currentUser.id);

      await unfollowVacation(userId, vacationId);
      res.sendStatus(204);
    } catch (error) {
      next(error);
    }
  }
);

=== dal\dal.ts ===
import { Pool, PoolClient, QueryResult } from "pg";
import { appConfig } from "../utils/config";

// const pool = new Pool({
//   host: appConfig.DB_HOST,
//   port: appConfig.DB_PORT,
//   user: appConfig.DB_USER,
//   password: appConfig.DB_PASSWORD,
//   database: appConfig.DB_NAME,
//   // ssl: {
//   //     rejectUnauthorized: false  // For testing. Use proper CA in production.
//   // }
// });

let pool: any;
if (Number(process.env.IS_PROD) === 1) {
  pool = new Pool({
    connectionString: appConfig.DB_URL,
    ssl: {
      rejectUnauthorized: false
    }
  })
} else {
  pool = new Pool({
    connectionString: appConfig.DB_URL,
  })
}

export async function openDb(): Promise<void> {
  const client = await pool.connect();
  try {
    await client.query("SELECT 1");
  } finally {
    client.release();
  }
}

export async function getDbClient(): Promise<PoolClient> {
  return pool.connect();
}

export async function runQuery(
  q: string,
  params: any[] = [],
  client?: PoolClient
) {
  const executor: { query: (text: string, params?: any[]) => Promise<QueryResult> } =
    client ?? pool;

  const res = await executor.query(q, params);

  if (res.rows && res.rows.length > 0) {
    return res.rows;
  }

  return {
    changes: res.rowCount,
  };
}

=== dal\initDb.ts ===
import { getDbClient, runQuery } from "./dal";

async function initDbSchema() {
    const ddl = `
BEGIN;

CREATE TABLE IF NOT EXISTS users (
 id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 first_name TEXT NOT NULL,
 last_name TEXT NOT NULL,
 email TEXT NOT NULL UNIQUE,
 password TEXT NOT NULL,
 is_admin BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS vacations (
 id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 destination TEXT NOT NULL,
 description TEXT NOT NULL,
 start_date TIMESTAMPTZ NOT NULL,
 end_date TIMESTAMPTZ NOT NULL,
 price NUMERIC(12,2) NOT NULL CHECK (price > 0 AND price <= 10000),
 image TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS followers (
  user_id BIGINT NOT NULL,
  vacation_id BIGINT NOT NULL,
  PRIMARY KEY (user_id, vacation_id),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (vacation_id) REFERENCES vacations(id) ON DELETE CASCADE
);

-- helpful indexes for FKs / lookups
CREATE INDEX IF NOT EXISTS idx_vacations_destination
    ON vacations(destination);

CREATE INDEX IF NOT EXISTS idx_vacations_start_date
    ON vacations(start_date);

CREATE INDEX IF NOT EXISTS idx_vacations_end_date
    ON vacations(end_date);

CREATE INDEX IF NOT EXISTS idx_followers_vacation_id
    ON followers(vacation_id);


COMMIT;
    `;

    await runQuery(ddl, [], undefined);
}

async function generateSampleData() {
    const dbClient = await getDbClient();

    try {
        await runQuery("BEGIN;", [], dbClient);

        // Table cleaning
        // await runQuery(
        //     "TRUNCATE TABLE followers, vacations, users RESTART IDENTITY CASCADE;",
        //     [],
        //     dbClient
        // );

        // users
        await runQuery(
            `INSERT INTO users (id, first_name, last_name, email, password, is_admin) VALUES
                (1,  'Admin', 'User',    'admin@example.com',          'admin',     true),
                (2,  'David', 'Cohen',   'david.cohen@example.com',    'password2', false),
                (3,  'Noa',   'Levi',    'noa.levi@example.com',       'password3', false),
                (4,  'Yair',  'Levi',    'yair.levi@example.com',      'password4', false),
                (5,  'Dana',  'Rozin',   'dana.rozin@example.com',     'password5', false),
                (6,  'Amit',  'Katz',    'amit.katz@example.com',      'password6', false),
                (7,  'Roni',  'Bar',     'roni.bar@example.com',       'password7', false),
                (8,  'Eli',   'Mizrahi', 'eli.mizrahi@example.com',    'password8', false),
                (9,  'Tal',   'Halevi',  'tal.halevi@example.com',     'password9', false),
                (10, 'Lior',  'Aviv',    'lior.aviv@example.com',      'password10', false);
            `,
            [],
            dbClient
        );

        // vacations
        await runQuery(
            `INSERT INTO vacations (id, destination, description, start_date, end_date, price, image) VALUES
                (1,  'Paris', 'Romantic city break with museums, cafes and Seine river cruises',
                '2025-03-10 09:00:00+00', '2025-03-17 18:00:00+00', 2599.90, 'paris.jpg'),
                (2,  'New York', 'Urban adventure with shopping, Broadway shows and skyline views',
                '2025-04-01 10:00:00+00', '2025-04-08 20:00:00+00', 3299.00, 'newyork.jpg'),
                (3,  'Rome', 'Historic tour of ancient ruins, charming piazzas and Italian cuisine',
                '2025-05-05 08:00:00+00', '2025-05-12 19:00:00+00', 1999.50, 'rome.jpg'),
                (4,  'Barcelona', 'Beachside vacation with Gaudi architecture, tapas bars and lively streets',
                '2025-06-15 07:00:00+00', '2025-06-22 21:00:00+00', 1899.99, 'barcelona.jpg'),
                (5,  'Bangkok', 'Exotic trip with street food, golden temples and vibrant night markets',
                '2025-07-10 06:00:00+00', '2025-07-20 23:00:00+00', 3499.00, 'bangkok.jpg'),
                (6,  'Tokyo', 'Modern city experience with tech districts, shrines and fresh sushi',
                '2025-08-01 05:00:00+00', '2025-08-12 23:30:00+00', 3999.90, 'tokyo.jpg'),
                (7,  'London', 'Classic city break with museums, green parks and royal landmarks',
                '2025-09-05 09:30:00+00', '2025-09-12 19:30:00+00', 2399.00, 'london.jpg'),
                (8,  'Amsterdam', 'Canal-side holiday with bikes, art museums and cozy cafes',
                '2025-10-10 08:30:00+00', '2025-10-17 18:30:00+00', 2199.50, 'amsterdam.jpg'),
                (9,  'Berlin', 'Cultural city break with history, galleries and lively nightlife',
                '2025-11-01 07:30:00+00', '2025-11-08 20:30:00+00', 2099.00, 'berlin.jpg'),
                (10, 'Athens', 'Mediterranean escape with ancient ruins, sea views and island vibes',
                '2025-12-05 09:00:00+00', '2025-12-11 18:00:00+00', 1799.00, 'athens.jpg');
            `,
            [],
            dbClient
        );

        // followers
        await runQuery(
            `INSERT INTO followers (user_id, vacation_id) VALUES
                (2, 1),
                (3, 1),
                (4, 2),
                (5, 2),
                (6, 3),
                (7, 4),
                (8, 5),
                (9, 6),
                (10, 7),
                (3, 8);
            `,
            [],
            dbClient
        );

        await runQuery(
            `SELECT setval(
                pg_get_serial_sequence('users', 'id'),
                COALESCE((SELECT MAX(id) FROM users), 1),
                true
            );`,
            [],
            dbClient
        );

        await runQuery(
            `SELECT setval(
                pg_get_serial_sequence('vacations', 'id'),
                COALESCE((SELECT MAX(id) FROM vacations), 1),
                true
            );`,
            [],
            dbClient
        );

        await runQuery("COMMIT;", [], dbClient);
    } catch (error) {
        await runQuery("ROLLBACK;", [], dbClient);
        throw error;
    } finally {
        dbClient.release();
    }
}

async function main() {
    try {
        console.log("Starting init DB");

        const dbInfo = await runQuery("SELECT current_database() AS db;");
        console.log("Connected to DB:", dbInfo[0].db);

        await generateSampleData();

        console.log("Done init DB");
    } catch (err) {
        console.error("Fatal error in initDb:");
        console.error(err);
        process.exitCode = 1;
    }
}
main();

=== helpers\generalHelpers.ts ===
import { openDb } from "../dal/dal";

export async function isDBup(): Promise<boolean> {
  try {
    await openDb();
    return true;
  } catch (error) {
    console.error("DB health check failed");
    console.error(error);
    return false;
  }
}

=== helpers\logHelpers.ts ===
import fs from "fs";
import { appConfig } from "../utils/config";

export function logIt(message: string, isError: boolean = false): void {
  const now = new Date().toISOString();
  const line = `[${now}] ${message}\n`;

  const filePath = isError
    ? appConfig.errorLogFile
    : appConfig.accessLogFile;

  try {
    fs.appendFile(filePath, line, (err) => {
      if (err) {
        console.error("Failed to write log file:", err);
      }
    });
  } catch (err) {
    console.error("Unexpected log write error:", err);
  }

  if (isError) {
    console.error(line);
  } else {
    console.log(line);
  }
}

=== helpers\s3Helpers.ts ===
import { PutObjectCommand, S3Client, DeleteObjectCommand } from "@aws-sdk/client-s3";
import fs from "fs";
import { appConfig } from "../utils/config";
import { Readable } from "stream";
import { Upload } from "@aws-sdk/lib-storage";

function getS3Client() {
    const accessKeyId = appConfig.s3_config.key;
    const secretAccessKey = appConfig.s3_config.secret;
    const region = appConfig.s3_config.region;

    const s3Client = new S3Client({
        region,
        credentials: {
            accessKeyId,
            secretAccessKey
        },
    })
    return s3Client;
}

export async function uploadToS3Readable(fileStream: Readable, fileName: string): Promise<void> {
    const client = getS3Client();

    const upload = new Upload({
        client,
        params: {
            Bucket: appConfig.s3_config.bucket_name,
            Key: appConfig.s3_config.imagesVacationFolder + "/" + fileName,
            Body: fileStream
        }
    });

    try {
        await upload.done();
        console.log("Readable file successfully uploaded");
    } catch (error) {
        console.log("ERROR Readable file not uploaded", error);
    }
}

async function uploadToS3(filePath: string, fileName: string): Promise<void> {

    const bucket = appConfig.s3_config.bucket_name;
    const s3Client = getS3Client()

    const fileStream = fs.createReadStream(filePath);

    const uploadParams = {
        Bucket: bucket,
        Key: appConfig.s3_config.image_folder + "/" + fileName,
        Body: fileStream
    }

    try {
        const command = new PutObjectCommand(uploadParams);
        const result = await s3Client.send(command);
        console.log(`File successfully uploaded to ${bucket}. name: ${fileName}. result: \n${result}`);

    } catch (error) {
        console.log("Error during upload to S3. more info:", error);
    }

}

async function deleteFromS3(objectName: string) {

    const s3Client = getS3Client()
    const bucket = appConfig.s3_config.bucket_name;

    const deleteParams = {
        Bucket: bucket,
        // Key: objectName
        Key: appConfig.s3_config.image_folder + "/" + objectName
    }

    try {
        const command = new DeleteObjectCommand(deleteParams);
        const res = await s3Client.send(command);
        console.log(`Object ${objectName} successfully deleted from S3 ${bucket} `);
    } catch (error) {
        console.log("Error during deleting from S3: ", error);
    }
}

=== middlewares\errorsHandler.ts ===
import { NextFunction, Request, Response } from "express";
import { AppException } from "../models/exceptions";
import { StatusCode } from "../models/statusCode";
import { logIt } from "../helpers/logHelpers";

export function errorHandler(
  error: any,
  request: Request,
  response: Response,
  next: NextFunction
) {
  // If a response has already been sent, don't attempt to modify it
  if (response.headersSent) {
    return next(error);
  }

  // Known application error
  if (error instanceof AppException) {
    return response
      .status(error.status)
      .json({ message: error.message });
  }

  // Unknown error
  const msg = `Unknown error. message: ${error?.message}.\nTB:\n${error?.stack}`;
  logIt(msg, true);

  return response
    .status(StatusCode.ServerError)
    .json({ message: "Internal Server Error" });
}

export default errorHandler;

=== middlewares\verifyAdmin.ts ===
import { Request, Response, NextFunction } from "express";

export default function verifyAdmin(req: Request, res: Response, next: NextFunction) {
  const user = (req as any).user;

  const isAdmin = Boolean(user?.isAdmin ?? user?.is_admin);
  if (!isAdmin) {
    return res.status(403).json({ message: "Admin only" });
  }

  next();
}

=== middlewares\verifyLoggedIn.ts ===
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";
import { appConfig } from "../utils/config";

export default function verifyLoggedIn(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ message: "Missing authentication token" });
  }

  const token = authHeader.substring(7);
  try {
    const payload = jwt.verify(token, appConfig.jwtSecret) as any;
    (req as any).user = payload;
    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid or expired token" });
  }
}

=== middlewares\verifyNotAdmin.ts ===
import { Request, Response, NextFunction } from "express";

export default function verifyNotAdmin(req: Request, res: Response, next: NextFunction) {
  const user = (req as any).user;
  const isAdmin = Boolean(user?.isAdmin ?? user?.is_admin);

  if (isAdmin) {
    return res.status(403).json({ message: "Users only" });
  }

  next();
}

=== services\userServices.ts ===
import { runQuery } from "../dal/dal";
import jwt from "jsonwebtoken";
import { appConfig } from "../utils/config";
import { CredentialsModel, UserModel } from "../models/UserModel";
import { ValidationException, AuthException } from "../models/exceptions";

interface JwtUserPayload {
  id: number;
  firstName: string;
  lastName: string;
  email: string;
  isAdmin: boolean;
}

// Map a DB row to `UserModel`
function mapRowToUserModel(row: any): UserModel {
  return new UserModel({
    id: row.id,
    first_name: row.first_name,
    last_name: row.last_name,
    email: row.email,
    password: row.password,
    is_admin: row.is_admin,
  } as UserModel);
}

// Create JWT for a user
function createToken(user: UserModel): string {
  const payload: JwtUserPayload = {
    id: user.id!,
    firstName: user.first_name,
    lastName: user.last_name,
    email: user.email,
    isAdmin: user.is_admin,
  };

  return jwt.sign(payload, appConfig.jwtSecret, { expiresIn: "7d" });
}

// Find a user by email
async function getUserByEmail(email: string): Promise<UserModel | null> {
  const q = `
    SELECT id, first_name, last_name, email, password, is_admin
    FROM users
    WHERE email = $1
    LIMIT 1;
  `;

  const rows = (await runQuery(q, [email])) as any[];

  if (!rows.length) return null;

  return mapRowToUserModel(rows[0]);
}

// Check if an email is available
export async function isEmailFree(email: string): Promise<boolean> {
  const user = await getUserByEmail(email);
  return !user;
}

// Register a new user — returns a JWT
export async function registerUser(data: {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}): Promise<string> {
  const { firstName, lastName, email, password } = data;

  // Validations — all throw `ValidationException`
  if (!firstName?.trim() || !lastName?.trim() || !email?.trim() || !password) {
    throw new ValidationException("All fields are required");
  }

  if (password.length < 5) {
    throw new ValidationException("Password must be at least 4 characters");
  }

  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    throw new ValidationException("Invalid email format");
  }

  const free = await isEmailFree(email);
  if (!free) {
    throw new ValidationException("Email is already in use");
  }

  const insertQuery = `
    INSERT INTO users (first_name, last_name, email, password, is_admin)
    VALUES ($1, $2, $3, $4, false)
    RETURNING id, first_name, last_name, email, password, is_admin;
  `;

  const rows = (await runQuery(insertQuery, [
    firstName,
    lastName,
    email,
    password,
  ])) as any[];

  const newUser = mapRowToUserModel(rows[0]);

  const token = createToken(newUser);
  return token;
}

// User login — returns a JWT
export async function login(credentials: CredentialsModel): Promise<string> {
  const { email, password } = credentials;

  // Validation — missing email/password
  if (!email || !password) {
    throw new ValidationException("Email and password are required");
  }

  const user = await getUserByEmail(email);
  if (!user) {
    // User does not exist
    throw new AuthException("Incorrect email or password");
  }

  if (user.password !== password) {
    // Password does not match
    throw new AuthException("Incorrect email or password");
  }

  const token = createToken(user);
  return token;
}

=== services\vacationServices.ts ===
import { runQuery } from "../dal/dal";
import { ValidationException, AppException } from "../models/exceptions";
import { StatusCode } from "../models/statusCode";

export interface VacationDto {
  id: number;
  destination: string;
  description: string;
  startDate: string;
  endDate: string;
  price: number;
  image: string;
  followersCount: number;
  isFollowedByCurrentUser?: boolean;
}

export interface VacationReportDto {
  destination: string;
  followersCount: number;
}

export interface AddVacationInput {
  destination: string;
  description: string;
  startDate: string;
  endDate: string;
  price: number;
  image: string;
}

export interface UpdateVacationInput {
  id: number;
  destination: string;
  description: string;
  startDate: string;
  endDate: string;
  price: number;
  image?: string;
}

export type VacationsFilter = "all" | "following" | "upcoming" | "active";

export interface VacationsQueryOptions {
  page?: number;
  pageSize?: number;
  filter?: VacationsFilter;
}

function mapRowToVacationDto(row: any): VacationDto {
  return {
    id: row.id,
    destination: row.destination,
    description: row.description,
    startDate: row.startDate,
    endDate: row.endDate,
    price: Number(row.price),
    image: row.image,
    followersCount: Number(row.followersCount ?? 0),
    isFollowedByCurrentUser:
      typeof row.isFollowedByCurrentUser === "boolean"
        ? row.isFollowedByCurrentUser
        : undefined,
  };
}

function parseDate(value: string): Date {
  const d = new Date(value);
  if (isNaN(d.getTime())) {
    throw new ValidationException(`Invalid date: ${value}`);
  }
  return d;
}

function ensureNonEmptyText(value: any, fieldName: string): void {
  if (typeof value !== "string" || value.trim().length === 0) {
    throw new ValidationException(`${fieldName} is required`);
  }
}

function ensurePriceValid(price: number): void {
  if (price <= 0 || price > 10000) {
    throw new ValidationException(
      "Price must be greater than 0 and at most 10000"
    );
  }
}

function ensureDatesValidForCreate(startDate: string, endDate: string): void {
  const start = parseDate(startDate);
  const end = parseDate(endDate);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  if (end < start) {
    throw new ValidationException("End date cannot be earlier than start date");
  }

  if (start < today || end < today) {
    throw new ValidationException(
      "Past dates are not allowed for new vacations"
    );
  }
}

function ensureDatesValidForUpdate(startDate: string, endDate: string): void {
  const start = parseDate(startDate);
  const end = parseDate(endDate);

  if (end < start) {
    throw new ValidationException("End date cannot be earlier than start date");
  }
}

function escapeCsv(value: string): string {
  if (
    value.includes('"') ||
    value.includes(",") ||
    value.includes("\n") ||
    value.includes("\r")
  ) {
    return `"${value.replace(/"/g, '""')}"`;
  }
  return value;
}

// All holidays + number of followers
export async function getVacations(): Promise<VacationDto[]> {
  const q = `
    SELECT
      v.id,
      v.destination,
      v.description,
      v.start_date AS "startDate",
      v.end_date AS "endDate",
      v.price,
      v.image,
      COUNT(f.user_id) AS "followersCount"
    FROM vacations v
    LEFT JOIN followers f
      ON v.id = f.vacation_id
    GROUP BY v.id
    ORDER BY v.start_date;
  `;

  const rows = (await runQuery(q)) as any[];

  return rows.map(mapRowToVacationDto);
}

// All vacations + number of followers + whether the current user is following
export async function getVacationsForUser(
  userId: number,
  options: VacationsQueryOptions = {}
): Promise<{ vacations: VacationDto[]; totalCount: number }> {
  const pageRaw = options.page ?? 1;
  const pageSizeRaw = options.pageSize ?? 6;

  const page = pageRaw > 0 ? pageRaw : 1;
  const pageSize = pageSizeRaw > 0 ? pageSizeRaw : 6;

  const allowedFilters: VacationsFilter[] = ["all", "following", "upcoming", "active"];
  const filter: VacationsFilter =
    options.filter && allowedFilters.includes(options.filter)
      ? options.filter
      : "all";

  const offset = (page - 1) * pageSize;

  const whereParts: string[] = [];
  const params: any[] = [userId];

  if (filter === "following") {
    // Only vacations that the user is following
    whereParts.push(`
      EXISTS (
        SELECT 1
        FROM followers fx
        WHERE fx.vacation_id = v.id
          AND fx.user_id = $1
      )
    `);
  } else if (filter === "upcoming") {
    // Vacations that haven't started yet
    whereParts.push(`v.start_date > NOW()`);
  } else if (filter === "active") {
    // Vacations that are currently active
    whereParts.push(`v.start_date <= NOW() AND v.end_date >= NOW()`);
  }

  const whereClause =
    whereParts.length > 0 ? "WHERE " + whereParts.join(" AND ") : "";

  // Data query with LIMIT/OFFSET
  const dataQuery = `
    SELECT
      v.id,
      v.destination,
      v.description,
      v.start_date AS "startDate",
      v.end_date AS "endDate",
      v.price,
      v.image,
      COUNT(f.user_id) AS "followersCount",
      COUNT(*) FILTER (WHERE f.user_id = $1) > 0 AS "isFollowedByCurrentUser"
    FROM vacations v
    LEFT JOIN followers f
      ON v.id = f.vacation_id
    ${whereClause}
    GROUP BY v.id
    ORDER BY v.start_date
    LIMIT ${pageSize}
    OFFSET ${offset};
  `;

  const rows = (await runQuery(dataQuery, params)) as any[];
  const vacations = rows.map(mapRowToVacationDto);

  let countQuery: string;
  let countParams: any[];

  if (filter === "following") {
    // Only vacations that the user is following
    countQuery = `
      SELECT COUNT(DISTINCT v.id) AS cnt
      FROM vacations v
      JOIN followers f
        ON v.id = f.vacation_id
      WHERE f.user_id = $1;
    `;
    countParams = [userId];
  } else {
    countQuery = `
      SELECT COUNT(*) AS cnt
      FROM vacations v
      ${whereClause};
    `;
    countParams = [];
  }

  const countRows = (await runQuery(countQuery, countParams)) as any[];
  const totalCount = Number(countRows[0].cnt);

  return { vacations, totalCount };
}


// Single vacation by id, including followersCount, and if userId is provided — also isFollowedByCurrentUser
export async function getVacationById(
  vacationId: number,
  currentUserId?: number
): Promise<VacationDto | null> {
  let q: string;
  let params: any[];

  if (currentUserId != null) {
    q = `
      SELECT
        v.id,
        v.destination,
        v.description,
        v.start_date AS "startDate",
        v.end_date AS "endDate",
        v.price,
        v.image,
        COUNT(f.user_id) AS "followersCount",
        COUNT(*) FILTER (WHERE f.user_id = $2) > 0 AS "isFollowedByCurrentUser"
      FROM vacations v
      LEFT JOIN followers f
        ON v.id = f.vacation_id
      WHERE v.id = $1
      GROUP BY v.id;
    `;
    params = [vacationId, currentUserId];
  } else {
    q = `
      SELECT
        v.id,
        v.destination,
        v.description,
        v.start_date AS "startDate",
        v.end_date AS "endDate",
        v.price,
        v.image,
        COUNT(f.user_id) AS "followersCount"
      FROM vacations v
      LEFT JOIN followers f
        ON v.id = f.vacation_id
      WHERE v.id = $1
      GROUP BY v.id;
    `;
    params = [vacationId];
  }

  const rows = (await runQuery(q, params)) as any[];
  if (!rows.length) return null;

  return mapRowToVacationDto(rows[0]);
}

//* For admin *//
export async function addVacation(data: AddVacationInput): Promise<VacationDto> {
  const { destination, description, startDate, endDate, price, image } = data;

  ensureNonEmptyText(destination, "Destination");
  ensureNonEmptyText(description, "Description");
  ensureNonEmptyText(image, "Image");
  ensurePriceValid(price);
  ensureDatesValidForCreate(startDate, endDate);

  const q = `
    INSERT INTO vacations (destination, description, start_date, end_date, price, image)
    VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING
      id,
      destination,
      description,
      start_date AS "startDate",
      end_date AS "endDate",
      price,
      image;
  `;

  const rows = (await runQuery(q, [
    destination,
    description,
    startDate,
    endDate,
    price,
    image,
  ])) as any[];

  const row = rows[0];

  // New vacation — no followers yet
  return {
    id: row.id,
    destination: row.destination,
    description: row.description,
    startDate: row.startDate,
    endDate: row.endDate,
    price: Number(row.price),
    image: row.image,
    followersCount: 0,
    isFollowedByCurrentUser: false,
  };
}

export async function updateVacation(data: UpdateVacationInput): Promise<VacationDto> {
  const { id, destination, description, startDate, endDate, price, image } =
    data;

  ensureNonEmptyText(destination, "Destination");
  ensureNonEmptyText(description, "Description");
  ensurePriceValid(price);
  ensureDatesValidForUpdate(startDate, endDate);

  const values: any[] = [
    destination,
    description,
    startDate,
    endDate,
    price,
  ];

  let setClause = `
    destination = $1,
    description = $2,
    start_date = $3,
    end_date = $4,
    price = $5
  `;

  if (image) {
    values.push(image);
    setClause += `, image = $${values.length}`;
  }

  values.push(id);

  const q = `
    UPDATE vacations
    SET ${setClause}
    WHERE id = $${values.length}
    RETURNING
      id,
      destination,
      description,
      start_date AS "startDate",
      end_date AS "endDate",
      price,
      image;
  `;

  const rows = (await runQuery(q, values)) as any[];

  if (!rows.length) {
    throw new AppException("Vacation not found", StatusCode.NotFound);
  }

  const row = rows[0];

  return {
    id: row.id,
    destination: row.destination,
    description: row.description,
    startDate: row.startDate,
    endDate: row.endDate,
    price: Number(row.price),
    image: row.image,
    followersCount: 0,
  };
}

export async function deleteVacation(id: number): Promise<void> {
  const q = `DELETE FROM vacations WHERE id = $1;`;
  await runQuery(q, [id]);
}

//  Follow / Unfollow
export async function followVacation(
  userId: number,
  vacationId: number
): Promise<void> {
  await runQuery(
    `
      INSERT INTO followers (user_id, vacation_id)
      VALUES ($1, $2)
      ON CONFLICT (user_id, vacation_id) DO NOTHING;
    `,
    [userId, vacationId]
  );
}

export async function unfollowVacation(
  userId: number,
  vacationId: number
): Promise<void> {
  await runQuery(
    `
      DELETE FROM followers
      WHERE user_id = $1 AND vacation_id = $2;
    `,
    [userId, vacationId]
  );
}

// Reports for admin
export async function getVacationsReport(): Promise<VacationReportDto[]> {
  const q = `
    SELECT
      v.id,
      v.destination,
      COUNT(f.user_id) AS "followersCount"
    FROM vacations v
    LEFT JOIN followers f
      ON v.id = f.vacation_id
    GROUP BY v.id, v.destination
    ORDER BY v.destination;
  `;

  const rows = (await runQuery(q)) as any[];

  return rows.map((r) => ({
    destination: r.destination,
    followersCount: Number(r.followersCount ?? 0),
  }));
}

export async function generateCsvReport(): Promise<string> {
  const report = await getVacationsReport();

  let csv = "destination,followersCount\n";

  csv += report
    .map((r) => `${escapeCsv(r.destination)},${r.followersCount}`)
    .join("\n");

  return csv;
}

=== utils\config.ts ===
import path from "path";
import dotenv from "dotenv";

dotenv.config()

class BaseConfig {
    // readonly routsPrefix = "/api/v1/";
    accessLogFile = __dirname + "\\..\\..\\logs\\accessLog.log";
    errorLogFile = path.resolve(__dirname, "..", "..", "logs", "errorLog.log");
    productImagesPrefix = path.resolve(__dirname, "..", "..", "assets", "images")
    tokenSecretKey = process.env.TOKEN_SECRET_KEY;
    jwtSecret = process.env.JWT_SECRET || process.env.TOKEN_SECRET_KEY || "very-secret-dev-key";
    DB_PORT = 5432;

    readonly s3_config = {
        key: process.env.S3_KEY,
        secret: process.env.S3_SECRET,
        region: "eu-central-1",
        bucket_name: "class63bucket",
        image_folder: "myFolder",
        imagesVacationFolder: "vacationImages"

    }
}

class DevConfig extends BaseConfig {
    DB_USER = "app";
    DB_PASSWORD = "app123";
    DB_HOST = "localhost";
    DB_NAME = "appdb";

    DB_URL = `postgres://${this.DB_USER}:${this.DB_PASSWORD}@${this.DB_HOST}:${this.DB_PORT}/${this.DB_NAME}`
    port = 3030;
}

class ProdConfig extends BaseConfig {
    DB_FILE = __dirname + "\\..\\..\\prod_sqlite.db";
    port = 3033;

    DB_USER = process.env.DB_USER;
    DB_PASSWORD = process.env.DB_PASSWORD;
    DB_HOST = process.env.DB_HOST;
    DB_NAME = process.env.DB_NAME;

    DB_URL = `postgres://${this.DB_USER}:${this.DB_PASSWORD}@${this.DB_HOST}:${this.DB_PORT}/${this.DB_NAME}`;
}

export const appConfig = Number(global.process.env.IS_PROD) === 1 ? new ProdConfig() : new DevConfig();

